# 所有權基礎：Rust 的核心規則

所有權 (Ownership) 是 Rust 語言最獨特且重要的概念之一，也是確保記憶體安全的核心機制。對於初學者來說，理解所有權是學習 Rust 的第一步。本文將介紹所有權的基本規則與應用，幫助您快速掌握這一基礎概念。

---

## 什麼是所有權？

在 Rust 中，每個值（數據）都有一個明確的所有者（通常是一個變數），負責管理該值的記憶體。當所有者超出作用域時，該值的記憶體會自動釋放，無需手動管理或垃圾回收。這種設計避免了記憶體洩漏和使用後釋放 (use-after-free) 等錯誤。

所有權的核心理念是：**記憶體管理由編譯器在編譯時檢查，確保安全與高效。**

---

## 所有權的三大基本規則

Rust 的所有權系統基於以下三個簡單但嚴格的規則：

1. **每個值只有一個可變的所有者**：在任意時刻，一個值只能被一個變數擁有，且該變數可以修改該值。
2. **值可以被多個不可變借用**：如果值不被修改，可以有多個變數以「只讀」方式借用該值。
3. **當所有者超出作用域時，值會被自動釋放**：無需手動釋放記憶體，Rust 會在變數超出作用域時自動清理。

這些規則確保了記憶體安全，防止數據競賽和懸垂指針等問題。

---

## 所有權的基本應用

讓我們通過簡單的代碼示例來理解所有權：

```rust
fn main() {
    // 創建一個 String 值，s 是其所有者
    let s = String::from("hello");

    // 將 s 的所有權轉移給 s2
    let s2 = s;
    
    // 以下行會導致編譯錯誤，因為 s 已不再擁有該值
    // println!("s = {}", s);
    // 正確使用 s2，因為它現在是所有者
    println!("s2 = {}", s2);
}
```

在這個例子中：

- `s` 最初擁有 `String` 值的所有權。
- 當 `s` 的值被賦值給 `s2` 時，所有權轉移，`s` 不再有效。
- Rust 編譯器會阻止對 `s` 的訪問，避免使用無效數據。

---

## 借用 (Borrowing) 介紹

除了所有權轉移，Rust 還允許通過「借用」來訪問值，而不轉移所有權。借用分為兩種：

- **不可變借用**：以只讀方式訪問值，使用 `&` 符號。
- **可變借用**：以可寫方式訪問值，使用 `&mut` 符號，但同一時間只能有一個可變借用。

```rust
fn main() {

    let mut s = String::from("hello");
    
    // 不可變借用
    let r1 = &s;
    println!("r1 = {}", r1);
    
    // 可變借用
    let r2 = &mut s;
    r2.push_str(", world");
    println!("r2 = {}", r2);
}
```

借用規則確保了數據訪問的安全性，避免多個可變引用導致的競賽條件。

---

## 學習建議

- **練習所有權轉移**：編寫簡單程式，觀察所有權轉移時變數的行為，理解為什麼某些代碼會導致編譯錯誤。
- **熟悉借用規則**：嘗試使用不可變和可變借用，觀察編譯器如何阻止不安全的訪問。
- **閱讀錯誤訊息**：當遇到所有權相關的編譯錯誤時，仔細閱讀錯誤訊息，理解其背後的規則。
