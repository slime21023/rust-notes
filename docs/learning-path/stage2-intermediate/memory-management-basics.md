# 記憶體管理基礎：Rust 的安全與高效

記憶體管理是 Rust 語言的核心特性之一，旨在讓開發者能在不依賴垃圾回收的情況下，安全高效地管理記憶體。

對於有基本 Rust 知識的學習者來說，理解記憶體管理的基礎是掌握 Rust 設計理念的重要一步。

---

## 什麼是記憶體管理？

記憶體管理是指程式如何分配、訪問和釋放計算機記憶體的過程。在系統編程中，記憶體管理直接影響程式的性能與安全性。

Rust 的記憶體管理機制通過所有權系統，在編譯時確保記憶體安全，無需垃圾回收或手動釋放。

Rust 記憶體管理的核心理念是：**通過所有權與借用規則，在編譯時自動管理記憶體，兼顧安全與性能。**

---

## 為什麼 Rust 的記憶體管理獨特？

傳統語言中的記憶體管理可能存在問題，例如：

- **手動管理 (如 C/C++)**：開發者需要手動分配和釋放記憶體，容易導致洩漏或使用後釋放錯誤。
- **垃圾回收 (如 Java)**：雖然簡化了記憶體管理，但引入了運行時開銷和不可預測的暫停。
- **不安全訪問**：多個指針同時訪問同一記憶體，可能導致數據競賽或未定義行為。

Rust 通過所有權系統解決了這些問題，確保記憶體在編譯時被正確管理，無需運行時開銷。

---

## 記憶體管理的基本機制

### 棧與堆記憶體

Rust 中的記憶體分為兩大類：

- **棧 (Stack)**：用於存放固定大小的數據，如基本型別和局部變數，分配與釋放由編譯器自動管理，速度快。
- **堆 (Heap)**：用於存放動態大小的數據，如 `String` 和 `Vec`，需要顯式分配，Rust 通過所有權系統自動釋放。

```rust
fn main() {
    // 存於棧上，固定大小
    let x: i32 = 5; 

    // 存於堆上，動態大小
    let y: String = String::from("Hello"); 
    
    println!("x = {}, y = {}", x, y);
    // 當函數結束時，x 和 y 的記憶體自動釋放
}
```

### 所有權與記憶體釋放

Rust 的所有權系統確保每個值有一個唯一的所有者，當所有者超出作用域時，值會自動釋放：

```rust
fn main() {
    {
        // s 擁有堆上的數據
        let s = String::from("Hello"); 
        println!("s = {}", s);
    } 
    
    // s 超出作用域，堆記憶體自動釋放
    // 以下行會導致編譯錯誤，因為 s 已無效
    // println!("s = {}", s);
}
```

這種自動釋放機制避免了手動管理記憶體的複雜性與錯誤。

### 借用與記憶體訪問

借用允許在不轉移所有權的情況下訪問數據，Rust 通過借用規則確保記憶體訪問安全：

- 不可變借用 (`&T`)：允許多個只讀訪問。
- 可變借用 (`&mut T`)：允許單一可寫訪問，防止數據競賽。

```rust
fn main() {
    let mut s = String::from("Hello");
    // 不可變借用
    let r1 = &s; 

    // 另一個不可變借用
    let r2 = &s; 
    println!("r1 = {}, r2 = {}", r1, r2);

    // 以下行會導致編譯錯誤，因為不可變借用存在時不能有可變借用
    // let r3 = &mut s;
}
```

---

## 學習建議

- **理解棧與堆的區別**：練習使用固定大小和動態大小的數據類型，觀察其記憶體分配行為。
- **熟悉所有權釋放**：編寫程式，觀察變數超出作用域時的行為，理解記憶體自動釋放的時機。
- **練習借用規則**：嘗試不同類型的借用組合，理解編譯器如何防止不安全訪問。